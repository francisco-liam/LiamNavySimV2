#pragma kernel FunctionKernel

struct ShipData
{
    float mass;
    float length;
    float attractionCoefficient;
    float attractiveExponent;
    float repulsiveCoefficient;
    float repulsiveExponent;
    float targetAngleCoefficient;
    float targetAngleExponent;
    float relativeBearingCoefficient;
    float relativeBearingExponent;
    int numFields;
    float3 position;
    float heading;
    float3 fieldPos;
    float3 movePosition;
    float3 frontPos;
    int commands;
};


int numShips;
int entity;

RWStructuredBuffer<float3> positions;
StructuredBuffer<ShipData> ships;


float3 NormalizeVector(float3 vec)
{
    float mag = sqrt(vec.x * vec.x + vec.y * vec.y + vec.z * vec.z);
    float3 newVec = float3(vec.x / mag, vec.y / mag, vec.z / mag);
    return newVec;
}

float VectorMagnitude(float3 vec)
{
    return sqrt(vec.x * vec.x + vec.y * vec.y + vec.z * vec.z);
}


#define PI 3.14159265358979323846
#define Deg2Rad (PI * 2) / 360.0
#define Rad2Deg 360 / (PI * 2)

float Clamp(float val, float min, float max)
{
    if (val < min)
        val = min;
    if (val > max)
        val = max;
    return val;
}

float Degrees360(float angleDegrees)
{
    float ad = angleDegrees;
    while (ad >= 360)
    {
        ad -= 360;
    }
    while (ad < 0)
    {
        ad += 360;
    }
    return ad;

 }

float VectorToHeadingDegrees(float3 v)
{
    return atan2(v.x, v.z) * Rad2Deg;
}

float AngleDiffPosNeg(float a, float b)
{
    float diff = a - b;
    if (diff > 180)
        return diff - 360;
    if (diff < -180)
        return diff + 360;
    return diff;
}

float CalculatePotential(float3 position, int entity)
{
    float3 attractivePotential = float3(0, 0, 0);
    float magnitude;

    if (ships[entity].commands != 0)
    {
        attractivePotential = ships[entity].movePosition - position;
        float3 tmp = NormalizeVector(attractivePotential);
        attractivePotential = tmp *
                ships[entity].attractionCoefficient * pow(VectorMagnitude(attractivePotential), ships[entity].attractiveExponent);
    }

    float3 repulsivePotential = float3(0, 0, 0);
    for (int i = 0; i < numShips; i++)
    {
        if(i == entity)
            continue;
        
        float3 diff = ships[i].fieldPos - position;
        float dist = VectorMagnitude(diff);
        float3 direc = NormalizeVector(diff);
        
        float3 taDiff = ships[i].position - ships[entity].frontPos;
        float targetAbsBearing = Degrees360(VectorToHeadingDegrees(taDiff));
        float targetRelativeBearing = Degrees360(AngleDiffPosNeg(targetAbsBearing, ships[entity].heading));
        float targetAngle = Degrees360(targetAbsBearing + 180 - ships[i].heading);

        float taCoeff = sin((targetAngle) * Deg2Rad);
        float rbCoeff = sin((targetRelativeBearing - 90.0) * Deg2Rad);
        float3 taField = direc * ships[i].targetAngleCoefficient * ships[i].mass / 40 * ships[i].length / 20 * taCoeff * pow(dist, ships[i].targetAngleExponent);
        float3 rbField = direc * ships[i].relativeBearingCoefficient * ships[i].mass / 40 * ships[i].length / 20 * rbCoeff * pow(dist, ships[i].relativeBearingExponent);
        if (dist < 1000)
        {
            repulsivePotential += direc * ships[i].mass / 40 * ships[i].length / 20 *
                    ships[i].repulsiveCoefficient / ships[i].numFields * pow(dist, ships[i].repulsiveExponent);
            if (taCoeff > 0)
            {
                repulsivePotential += taField;
            }
            else
            {
                attractivePotential += taField;
            }
            if (rbCoeff > 0)
            {
                repulsivePotential += rbField;
            }
            else
            {
                attractivePotential += rbField;
            }
        }
    }
    
    float potentialMag = VectorMagnitude(repulsivePotential) - VectorMagnitude(attractivePotential);
    
    magnitude = Clamp(potentialMag, -50, 50);

    return magnitude;
}

[numthreads(64, 1, 1)]
void FunctionKernel(uint3 id : SV_DispatchThreadID)
{ 
    float3 pos = positions[id.x];
    pos.y = 0;
    float mag = (CalculatePotential(pos, entity) / 50) * 400;
    positions[id.x] = float3(pos.x, mag, pos.z);
}